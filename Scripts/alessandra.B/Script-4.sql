--CREATE TABLE
CREATE TABLE coders AS 
	SELECT employee_id AS coder_id, first_name, last_name, hire_date, salary
	FROM hr.employees
	WHERE department_id = 60;


CREATE TABLE SIMPLE (
	SIMPLE_ID NUMBER(6,0) PRIMARY KEY, --numero intero a 6 cifre, oppure metto integer
	STATUS CHAR,
	NAME VARCHAR2(20), --STRINGA CHE CONTIENE MASSIMO 20 CARATTERI
	CODER_ID NUMBER --metto NUMBER perchè deve matchare con il tipo che c'è IN coders
	
);

ALTER TABLE SIMPLE
ADD COUNTER NUMBER(38,0);

ALTER TABLE SIMPLE
DROP COLUMN COUNTER; -- fai cadere la colonna counter con drop

SELECT TABLE_NAME
FROM USER_TABLES;

SELECT *
FROM SIMPLE;

ALTER TABLE SIMPLE
ADD CONSTRAINT SIMPLE_STATUS_CK CHECK (STATUS IN ('A','B','X')); --nome della tabella, colonna e CHECK
--IL CONSTRAINT funziona come limitazione, IN questo caso limita i valori che può assumere status

ALTER TABLE SIMPLEX
ADD CONSTRAINT simple_id_ck CHECK (MOD(SIMPLE_ID, 2) = 1); -- numero dispari (modulo è il resto della divisione intera, 0 se è pari e 1 se dispari)

ALTER TABLE SIMPLE
MODIFY NAME CONSTRAINT SIMPLE_NAME_NN NOT NULL;

INSERT INTO SIMPLE(SIMPLE_ID, STATUS, NAME, CODER_ID)
VALUES(11,'A','BAD STATUS', 1);

ALTER TABLE SIMPLE 
DROP CONSTRAINT SIMPLE_NAME_NN;

INSERT INTO SIMPLE
VALUES(3,'A', NULL,1);

ALTER TABLE CODERS 
ADD CONSTRAINT CODERS_PK PRIMARY KEY(CODER_ID);

ALTER TABLE SIMPLE
DROP COLUMN CODER_ID;

ALTER TABLE SIMPLE
ADD CONSTRAINT SIMPLE_CODER_ID_FK 
CODER_ID REFERENCES CODERS(CODER_ID) ON DELETE CASCADE; -- on delete cascade, eliminazione a cascata

--oppure
ALTER TABLE SIMPLE
ADD CONSTRAINT SIMPLE_CODER_ID_FK 
CODER_ID REFERENCES CODERS(CODER_ID) ON DELETE SET NULL; -- se mi viene eliminato il code 12, tutti quelli che lo usavano come foreign key posso decidere se eliminarli (cascade) o mettere null (set null)

UPDATE SIMPLE
SET CODER_ID = 12; --WARNING! WORKING ON ALL ROWS! 

ALTER TABLE SIMPLE
ADD CONSTRAINT SIMPLE_CODER_ID_FK 
CODER_ID REFERENCES CODERS(CODER_ID);

ALTER TABLE SIMPLE
DROP CONSTRAINT SIMPLE_CODER_ID_FK;

--ADD TO CODERS
--ID: 12, HIRE_DATE: TODAY, SALARY: 4000

INSERT INTO CODERS
VALUES(12,'Tom','Jones',SYSDATE,4000);


SELECT *
FROM CODERS;

INSERT INTO SIMPLE
VALUES(1,'A','first',103);

DELETE FROM SIMPLE
WHERE SIMPLE_ID = 3;

DELETE FROM SIMPLE
WHERE SIMPLE_ID = 11;

INSERT INTO SIMPLE
VALUES(3,'A','second',105);

INSERT INTO SIMPLE
VALUES(5,'A','missing',42);


DELETE FROM CODERS
WHERE CODER_ID = 12;

INSERT INTO SIMPLE
VALUES(5,'A','second',105);

DELETE FROM SIMPLE
WHERE SIMPLE_ID = 5;

ALTER TABLE SIMPLE
ADD CONSTRAINT SIMPLE_NAME_UQ UNIQUE(NAME);

ALTER TABLE CODERS
ADD CONSTRAINT CODERS_NAME_UQ UNIQUE(FIRST_NAME, LAST_NAME);


--this should fail
INSERT INTO CODERS
VALUES(12,'Valli','Pataballa',SYSDATE,4000);


SELECT TABLE_NAME, CONSTRAINT_NAME, STATUS
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SIMPLE';

DROP TABLE SIMPLE;


CREATE TABLE INFOS (
	SIMPLE_ID NUMBER(6,0) --numero intero a 6 cifre, oppure metto integer
	     CONSTRAINT INFOS_PK PRIMARY KEY,
	     CONSTRAINT INFOS_ID_CK CHECK (MOD(SIMPLE_ID, 2) = 1),
	     
	STATUS CHAR DEFAULT 'A' --se gli specifico qualocosa mette la stringa specificata, altrimenti mette 'A'
               CONSTRAINT INFOS_STATUS_CK CHECK (STATUS IN ('A','B','X')),
	NAME VARCHAR2(20) --STRINGA CHE CONTIENE MASSIMO 20 CARATTERI
	     CONSTRAINT INFOS_NAME_UQ UNIQUE,
	CODER_ID NUMBER      --metto NUMBER perchè deve matchare con il tipo che c'è IN coders
	     CONSTRAINT INFOS_CODER_ID_FK
	     REFERENCES CODERS(CODER_ID) ON DELETE CASCADE	
);

DROP TABLE INFOS;

INSERT INTO CODERS
VALUES(12,'Tom','Jones',SYSDATE,4000);

INSERT INTO INFOS
VALUES(3, DEFAULT,'second',12);

INSERT INTO INFOS
VALUES(1, 'A','first',12);

INSERT INTO INFOS (SIMPLE_ID, NAME, CODER_ID)
VALUES(5,'third',12);

DELETE FROM CODERS
WHERE CODER_ID = 12;

RENAME MY_STATUES TO MY_STATUSES;

--COMMENTS
COMMENT ON TABLE MY_STATUSES IS 'Some extra information on coders';

COMMENT ON COLUMN MY_STATUSES.STATUS IS 'Status in the statuses';

--
truncate TABLE MY_STATUSES; -- non è un comando dml--> cioè non è un comando rollback  (con truncate la tabella esiste ancora ma è vuota)
DROP TABLE MY_STATUSES; -- non è tanto più un comando dml (la tabella non esiste più)

--grant create sequence to oved;
CREATE SEQUENCE MY_SEQ;

SELECT * 
FROM USER_SEQUENCES;

SELECT MY_SEQ.NEXTVAL
FROM DUAL; -- primo valore che io volevo venisse generato. lo scopo delle sequenze è generare numeri univoci, se rieseguo la sequenza non mi comparirà mai lo stesso numero

ALTER SEQUENCE MY_SEQ INCREMENT BY 2; -- incrementa non più in base 1 ma 2

DROP SEQUENCE MY_SEQ;

CREATE SEQUENCE MY_SEQ
START WITH 5 INCREMENT BY 2; -- parte da 201 e poi sale di due in due, quidi genera sempre valori dispari

INSERT INTO MY_STATUSES
VALUES(MY_SEQ.NEXTVAL, DEFAULT, 'Bill', 103);

INSERT INTO MY_STATUSES
VALUES(MY_SEQ.NEXTVAL, DEFAULT, 'Tom', 105);


--grant create view to oved;
CREATE OR REPLACE VIEW RESTRICTED_CODERS AS 
	SELECT CODER_ID, FIRST_NAME, LAST_NAME
	FROM CODERS
	WITH READ ONLY;

SELECT *
FROM RESTRICTED_CODERS;

UPDATE RESTRICTED_CODERS
SET FIRST_NAME = 'Tom'
WHERE CODER_ID = 103;

DROP VIEW RESTRICTED_CODERS;

1.
CREATE TABLE MY_EMPLOYEES (

    ID NUMBER(4)
	     CONSTRAINT EMPLOYEES_PK PRIMARY KEY,    
	LAST_NAME VARCHAR2(25),         
	FIRST_NAME VARCHAR2(25), 
	USERID VARCHAR2(8),   
    SALARY NUMBER (9,2)
);

DROP TABLE EMPLOYEES;
DROP TABLE MY_EMPLOYEE;

2.

INSERT INTO MY_EMPLOYEES
VALUES(1,'PATEL', 'RALPH','RPATEL', 895);

3.
INSERT INTO MY_EMPLOYEES (ID,LAST_NAME,FIRST_NAME,USERID,SALARY)
VALUES(2,'DANCS', 'BETTY','BADANCS', 860);

4.
INSERT INTO MY_EMPLOYEES (ID,LAST_NAME,FIRST_NAME,USERID,SALARY)
VALUES(3,'BIRI', 'BEN','BBIRI', 1100);

INSERT INTO MY_EMPLOYEES (ID,LAST_NAME,FIRST_NAME,USERID,SALARY)
VALUES(4,'NEWMAN', 'CHAD','CNEWMAN', 750);

INSERT INTO MY_EMPLOYEES (ID,LAST_NAME,FIRST_NAME,USERID,SALARY)
VALUES(5,'ROPEBURN', 'AUDREY','AROPEBUR', 1550);

5. 

UPDATE MY_EMPLOYEES
SET LAST_NAME = 'DREXEL'
WHERE ID = 3;

6. 

UPDATE MY_EMPLOYEES
SET SALARY = 1000
WHERE SALARY < 900;

7. 
DELETE FROM MY_EMPLOYEES
WHERE LAST_NAME = 'DANCS' AND FIRST_NAME = 'BETTY';

COMMIT;

8.
DELETE FROM MY_EMPLOYEES;

9.
ROLLBACK;


2.1
CREATE TABLE DEPT (
    ID NUMBER (7) CONSTRAINT DEPT_PK PRIMARY KEY,
    NAME VARCHAR2(25)
    );

 2.2
 CREATE TABLE EMP (
     ID NUMBER(7) CONSTRAINT EMP_PK PRIMARY KEY,
     LAST_NAME VARCHAR2(25),
     FIRST_NAME VARCHAR2(25),
     DEPT_ID NUMBER(7) CONSTRAINT EMP_DEPT_ID_FK REFERENCES DEPT(ID)
     ); 
 
 ALTER TABLE EMP
 ADD COMMISSION NUMBER(2,2);
 

ALTER TABLE EMP MODIFY(
LAST_NAME VARCHAR2(50)
);

ALTER TABLE EMP DROP(
FIRST_NAME
);

ALTER TABLE EMP SET UNUSED(DEPT_ID);

SELECT DEPT_ID
FROM EMP;

SELECT 
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'emp';

ALTER TABLE EMP DROP UNUSED COLUMN;

DROP TABLE EMP;

3.1

CREATE TABLE EMPLOYEES AS (
   SELECT EMPLOYEE_ID AS ID, FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID AS DEPT_ID
   FROM HR.EMPLOYEES
);

ALTER TABLE EMPLOYEES READ ONLY;

UPDATE EMPLOYEES
SET FIRST_NAME = 'TOM'
WHERE ID = 100;

ALTER TABLE EMPLOYEES READ WRITE;
TRUNCATE TABLE EMPLOYEES;

SELECT COUNT(ROWID) FROM EMPLOYEES;

DROP TABLE DEPT;
DROP TABLE EMPLOYEES;
DROP TABLE INFOS;
DROP TABLE CODERS;


BEGIN
	DBMS_OUTPUT.PUT_LINE('HELLO')

END;
