CREATE OR REPLACE PROCEDURE GET_CODER_NAME(

   P_CODER_ID IN CODERS.CODER_ID%TYPE,
   P_FIRST_NAME OUT CODERS.FIRST_NAME%TYPE,
   P_LAST_NAME OUT CODERS.LAST_NAME%TYPE
   ) AS 
   
   BEGIN
   SELECT FIRST_NAME, LAST_NAME
   INTO P_FIRST_NAME, P_LAST_NAME
   FROM CODERS
   WHERE CODER_ID = P_CODER_ID;
   
   
   END;
   /
   
   --TEST
 SET SERVEROUTPUT ON
  declare 
  V_FIRST_NAME CODERS.FIRST_NAME%TYPE;
  V_LAST_NAME CODERS.LAST_NAME%TYPE;
  
  begin
  GET_CODER_NAME(107, V_FIRST_NAME, V_LAST_NAME);
  DBMS_OUTPUT.PUT_LINE('CODER 107 is '|| V_FIRST_NAME ||' '|| V_LAST_NAME);
  
  end;
  
  --find max(a in, b in max out)
  --ex find_max(3,12, max) --> max = 12
  
  CREATE OR REPLACE PROCEDURE GET_MAX(

   P_A IN NUMBER,
   P_B IN NUMBER,
   P_MAX OUT NUMBER
   ) AS 
   
   BEGIN
   IF P_A > P_B THEN
       P_MAX := P_A;
       
    ELSE P_MAX := P_B;
   
   END IF;
   END;
   /
   
   --TEST
   
   DECLARE
   A NUMBER;
   B NUMBER;
   C NUMBER;
   
   BEGIN
   A := 56;
   B := 34;
   
   GET_MAX(A, B, C);
    DBMS_OUTPUT.PUT_LINE('MAX VALUE IS  '|| C);
    
   END;
   /
   
   CREATE OR REPLACE FUNCTION FIND_MAX(  -- NON è PIù UNA PROCEDURA MA UNA FUNZIONE, QUINDI HA UN RETURN

   P_A IN NUMBER,
   P_B IN NUMBER
 
   )RETURN NUMBER AS 
   --NO LOCAL VARIABLE HERE

   BEGIN
   IF P_A > P_B THEN
      RETURN P_A;
       
    ELSE RETURN P_B;
   
   END IF;
   END;
   /
  
  --TEST
   
   DECLARE
   A NUMBER;
   B NUMBER;
 
   BEGIN
   A := 18;
   B := 34;
   
    DBMS_OUTPUT.PUT_LINE('MAX VALUE IS  '|| FIND_MAX(A,B));
    
   END;
   /
   
   SELECT FIND_MAX(12,42)
   FROM DUAL;
   
   --MY_NVL(A,B) RETURN A WHEN A IS NOT NULL, ELSE RETURN B
   --SELECT COMMISSION_PCT
   --FROM HR.EMPLOYEES
   
   CREATE OR REPLACE FUNCTION MY_NUMERIC_NVL( 

   P_A IN NUMBER,
   P_B IN NUMBER
 
   )RETURN NUMBER AS 
   --NO LOCAL VARIABLE HERE

   BEGIN
   IF (P_A IS NOT NULL) THEN
      RETURN P_A;
       
    ELSE 
    RETURN P_B;
   
   END IF;
   END;
   /
   --TEST
   
 DECLARE
   A NUMBER;
   B NUMBER;
 
   BEGIN
   
   A := NULL;
   B := 34;
   
    DBMS_OUTPUT.PUT_LINE('MY NUMERIC NVL IS  '|| MY_NUMERIC_NVL(A,B));
    
   END;
   /  
   
   DECLARE
   A NUMBER;
   B NUMBER;
 
   BEGIN
   
   A := 23;
   B := 34;
   
    DBMS_OUTPUT.PUT_LINE('MY NUMERIC NVL IS  '|| MY_NUMERIC_NVL(A,B));
    
   END;
   /  
   
   SELECT HE.EMPLOYEE_ID,  MY_NUMERIC_NVL(HE.COMMISSION_PCT,0)
   FROM HR.EMPLOYEES HE;
   
   
   
CREATE OR REPLACE FUNCTION CIRCLE_AREA(
P_RADIUS IN NUMBER
) RETURN NUMBER AS

BEGIN

 RETURN 3.14 * P_RADIUS * P_RADIUS; --OPPURE RAGGIO AL QUADRARO POSSO SCRIVERLO : P_RADIUS**2
  
END;
/
--TEST 
DECLARE
V_RADIUS NUMBER;

BEGIN
   V_RADIUS := 3;
  DBMS_OUTPUT.PUT_LINE('MY CIRCLE AREA  IS '|| CIRCLE_AREA(V_RADIUS));

END;
/

--PROCEDURE INCREASE_SALARY_FOR_CODERS()
-- LOW, HIGH: ID INTERVAL CODERS_ID TO INCREASE SALARY
-- INCREASE: HOW MUCH TO INCREASE SALARIES

CREATE OR REPLACE PROCEDURE INCREASE_SALARY_FOR_CODERS(
P_LOW_ID IN CODERS.CODER_ID%TYPE,
P_HIGH_ID IN CODERS.CODER_ID%TYPE,
P_INCREASE IN NUMBER
) AS
CURSOR V_CURSOR_ID IS
  SELECT CODER_ID, SALARY
  FROM CODERS
  WHERE CODER_ID BETWEEN P_LOW_ID AND P_HIGH_ID;

V_CODER_ID CODERS.CODER_ID%TYPE;
V_SALARY CODERS.SALARY%TYPE;

BEGIN
 OPEN V_CURSOR_ID;
 
 LOOP 
 FETCH V_CURSOR_ID --leggimi il prossimo elemento nel cursore
 INTO V_CODER_ID, V_SALARY;
 V_SALARY := P_INCREASE + V_SALARY;
 EXIT WHEN V_CURSOR_ID%NOTFOUND; --quando notfound è true, so che non ho niente da vedere in più e quindi esco dal loop
      DBMS_OUTPUT.PUT_LINE('Coder  '|| V_CODER_ID|| ' has NEW SALARY ' ||V_SALARY);
      
  END LOOP;
END;
 / 
 
--TRIGGER , PROCEDURA  ESEGUITA AUTOMATICAMENTE DAL DATABASE NEL CASO IN CUI SI VERIFICHI QUALCOSA: al succedere di qualche evento si eseguono

